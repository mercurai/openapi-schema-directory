{"version":3,"sources":["/Users/erunion/code/readme/oas/packages/oas-normalize/dist/index.cjs","../src/index.ts"],"names":[],"mappings":"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","file":"/Users/erunion/code/readme/oas/packages/oas-normalize/dist/index.cjs","sourcesContent":[null,"import type { Options } from './lib/types.js';\nimport type { OpenAPI, OpenAPIV2, OpenAPIV3 } from 'openapi-types';\n\nimport fs from 'node:fs';\n\nimport openapiParser from '@readme/openapi-parser';\nimport postmanToOpenAPI from '@readme/postman-to-openapi';\nimport converter from 'swagger2openapi';\n\nimport * as utils from './lib/utils.js';\n\nexport default class OASNormalize {\n  cache: {\n    bundle?: OpenAPI.Document | false;\n    deref?: OpenAPI.Document | false;\n    load?: Record<string, unknown> | false;\n  };\n\n  file: any;\n\n  opts: Options;\n\n  type: ReturnType<typeof utils.getType>;\n\n  constructor(file: any, opts?: Options) {\n    this.file = file;\n    this.opts = {\n      colorizeErrors: false,\n      enablePaths: false,\n      ...opts,\n    };\n\n    this.type = utils.getType(this.file);\n\n    this.cache = {\n      load: false,\n      bundle: false,\n      deref: false,\n    };\n  }\n\n  /**\n   * @private\n   */\n  async load(): Promise<Record<string, unknown>> {\n    if (this.cache.load) return Promise.resolve(this.cache.load);\n\n    const resolve = (obj: Parameters<typeof utils.stringToJSON>[0]) => {\n      const ret = utils.stringToJSON(obj);\n      this.cache.load = ret;\n      return Promise.resolve(ret);\n    };\n\n    switch (this.type) {\n      case 'json':\n      case 'string-json':\n      case 'string-yaml':\n        return resolve(this.file);\n\n      case 'buffer':\n        return resolve(this.file.toString());\n\n      case 'url':\n        const resp = await fetch(utils.normalizeURL(this.file)).then(res => res.text());\n        return resolve(resp);\n\n      case 'path':\n        // Load a local file\n        if (!this.opts.enablePaths) {\n          return Promise.reject(new Error('Use `opts.enablePaths` to enable accessing local files.'));\n        }\n\n        const contents = fs.readFileSync(this.file).toString();\n        if (!contents.trim()) {\n          return Promise.reject(new Error('No file contents found.'));\n        }\n        return resolve(contents);\n\n      default:\n        return Promise.reject(new Error('Could not load this file.'));\n    }\n  }\n\n  /**\n   * @private\n   */\n  static async convertPostmanToOpenAPI(schema: any) {\n    return postmanToOpenAPI(JSON.stringify(schema), undefined, { outputFormat: 'json', replaceVars: true }).then(\n      JSON.parse,\n    );\n  }\n\n  /**\n   * Bundle up the given API definition, resolving any external `$ref` pointers in the process.\n   *\n   */\n  async bundle() {\n    if (this.cache.bundle) return Promise.resolve(this.cache.bundle);\n\n    return this.load()\n      .then(schema => {\n        // Though Postman collections don't support `$ref` pointers for us to bundle we'll still\n        // upconvert it to an OpenAPI definition file so our returned dataset is always one of\n        // those for a Postman dataset.\n        if (utils.isPostman(schema)) {\n          return OASNormalize.convertPostmanToOpenAPI(schema);\n        }\n\n        return schema;\n      })\n      .then(schema => openapiParser.bundle(schema))\n      .then(bundle => {\n        this.cache.bundle = bundle;\n        return bundle;\n      });\n  }\n\n  /**\n   * Dereference the given API definition.\n   *\n   */\n  async deref() {\n    if (this.cache.deref) return Promise.resolve(this.cache.deref);\n\n    return this.load()\n      .then(schema => {\n        // Though Postman collections don't support `$ref` pointers for us to dereference we'll\n        // still upconvert it to an OpenAPI definition file so our returned dataset is always one\n        // of those for a Postman dataset.\n        if (utils.isPostman(schema)) {\n          return OASNormalize.convertPostmanToOpenAPI(schema);\n        }\n\n        return schema;\n      })\n      .then(schema => openapiParser.dereference(schema))\n      .then(dereferenced => {\n        this.cache.deref = dereferenced;\n        return dereferenced;\n      });\n  }\n\n  /**\n   * Validate, and potentially convert to OpenAPI, a given API definition.\n   *\n   */\n  async validate(\n    opts: {\n      /**\n       * Automatically convert the supplied API definition to the latest version of OpenAPI.\n       */\n      convertToLatest?: boolean;\n      parser?: openapiParser.Options;\n    } = { convertToLatest: false },\n  ): Promise<OpenAPI.Document> {\n    const convertToLatest = opts.convertToLatest;\n    const parserOptions = opts.parser || {};\n    if (!parserOptions.validate) {\n      parserOptions.validate = {};\n    }\n\n    parserOptions.validate.colorizeErrors = this.opts.colorizeErrors;\n\n    return this.load()\n      .then(async schema => {\n        if (!utils.isPostman(schema)) {\n          return schema;\n        }\n\n        return OASNormalize.convertPostmanToOpenAPI(schema);\n      })\n      .then(async schema => {\n        if (!utils.isSwagger(schema) && !utils.isOpenAPI(schema)) {\n          return Promise.reject(new Error('The supplied API definition is unsupported.'));\n        } else if (utils.isSwagger(schema)) {\n          const baseVersion = parseInt(schema.swagger, 10);\n          if (baseVersion === 1) {\n            return Promise.reject(new Error('Swagger v1.2 is unsupported.'));\n          }\n        }\n\n        /**\n         * `openapiParser.validate()` dereferences schemas at the same time as validation and does\n         * not give us an option to disable this. Since all we already have a dereferencing method\n         * on this library and our `validate()` method here just needs to tell us if the definition\n         * is valid or not we need to clone it before passing it over to `openapi-parser` so as to\n         * not run into pass-by-reference problems.\n         */\n        // eslint-disable-next-line try-catch-failsafe/json-parse\n        const clonedSchema = JSON.parse(JSON.stringify(schema));\n\n        return openapiParser\n          .validate(clonedSchema, parserOptions)\n          .then(() => {\n            if (!convertToLatest || utils.isOpenAPI(schema)) {\n              return schema;\n            }\n\n            return converter\n              .convertObj(schema, { anchors: true })\n              .then((options: { openapi: OpenAPI.Document }) => options.openapi);\n          })\n          .catch(err => Promise.reject(err));\n      });\n  }\n\n  /**\n   * Retrieve OpenAPI, Swagger, or Postman version information about the supplied API definition.\n   *\n   */\n  async version(): Promise<{ specification: 'openapi' | 'postman' | 'swagger'; version: string | 'unknown' }> {\n    return this.load().then(schema => {\n      switch (utils.getAPIDefinitionType(schema)) {\n        case 'openapi':\n          return {\n            specification: 'openapi',\n            version: (schema as unknown as OpenAPIV3.Document).openapi,\n          };\n\n        case 'postman':\n          let version = 'unknown';\n          if ((schema?.info as Record<string, string>)?.schema) {\n            // Though `info.schema` is required by the Postman spec there's no strictness to its\n            // contents so we'll do our best to extract a version out of this schema URL that they\n            // seem to usually match. If not we'll fallback to treating it as an `unknown` version.\n            const match = (schema?.info as Record<string, string>).schema.match(\n              /http(s?):\\/\\/schema.getpostman.com\\/json\\/collection\\/v([0-9.]+)\\//,\n            );\n\n            if (match) {\n              version = match[2];\n            }\n          }\n\n          return {\n            specification: 'postman',\n            version,\n          };\n\n        case 'swagger':\n          return {\n            specification: 'swagger',\n            version: (schema as unknown as OpenAPIV2.Document).swagger,\n          };\n\n        default:\n          throw new Error('Unknown file detected.');\n      }\n    });\n  }\n}\n"]}